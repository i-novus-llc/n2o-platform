= Возможность seek-пагинации используя QueryDSL (по ключу, без офсетов и count-запросов)

== Как использовать:
1) Добавьте зависимость
[source,xml]
----
<dependency>
  <groupId>net.n2oapp.platform</groupId>
  <artifactId>n2o-platform-seek-paging</artifactId>
</dependency>
----
2) В своем приложении укажите
[source,java]
----
@EnableJpaRepositories(repositoryFactoryBeanClass = SeekableJpaRepositoryFactoryBean.class)
----
3) Репозитории, которые должны поддерживать seek-пагинацию, наследуйте от SeekableRepository.

== SeekableRepository
Данный интерфейс сам наследует QueryDslPredicateExecutor, поэтому все его методы доступны.

== Какие ограничения
Есть ограничения на NULL-значения (они не будут работать, seek-пагинация их пропустит).

Для решения этой проблемы, если возможно, нужно переделать структуру БД, добавить ограничения на NULL и т.п.

Можно завести некую запись, которое будет NULL-значением в контексте этой таблицы.

Если ничего из этого сделать не удается -- придется отказаться от seek-пагинации.

== Пагинация

=== Как это работает

1) Если нужна первая страница и сортировка производится скажем по колонкам (x1, x2, x3) как (ASC, DESC, ASC), тогда в
критерии в качестве *pivot*-ов должны быть заданы (min_x1, max_x2, min_x3).

2) Если нужна последняя страница, то для примера выше в критерии *pivot*-ы должны быть (max_x1, min_x2, max_x3)

3) Если нужна страница, следующая за текущей, в критерии должны быть указаны значения последней
записи текущей страницы.

4) Если нужна страница, предшествующая текущей, в критерии должны быть указаны значения первой записи текущей страницы.

Случаи 1 и 2 довольно проблематичны в плане того, что нам нужно сделать min или max запрос, чтобы знать от чего отталкиваться.
Но в большинстве случаев этого можно избежать, потому что заранее известно, какие значения будут максимальными/минимальными
для того или иного типа данных.

За эти минимальные/максимальные отвечает класс PivotProvider. Для каждого типа он должен вернуть значение,
считающееся в контексте этого репозитория (сущности) минимальным/максимальным. Реализации по-умолчанию *DefaultPivotProvider*
должно быть достаточно в общем случае. Если нет -- можно определить свой (или наследовать дефолтную реализацию). После над репозиторием следует указать:

[source,java]
----
import net.n2oapp.platform.seek.PivotProvided;
import net.n2oapp.platform.seek.SeekableRepository;

@PivotProvided(by = CustomPivotProvider.class)
public interface MyRepository extends SeekableRepository<...>
----

Например для строки минимальным значением будет пустая строка. С максимальным все не так просто, так как строка -- неограниченный тип данных.
Но мы можем взять максимальный code-point (0x10FFFF) и перевести его в строку, что в итоге даст нам кракозябру '􏿿'. Любая строка будет меньше этой,
кроме тех, что начинаются с этой кракозябры (чего в принципе не должно происходить на практике).

Вам не придется применять все эти правила самим (если вы используете `Spring-Data`), а лишь использовать классы
`SeekableCriteria`, `SeekedPage`, `SeekedPageIterator`.

Для других библиотек (скажем `jOOQ`) всегда можно добавить отдельную поддержку.