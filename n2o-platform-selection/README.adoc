= Selection API

== Для чего это

REST-сервисы страдают тем свойством, что зачастую отдают данных клиенту намного больше,
чем ему на самом деле нужно. Это приводит к неоптимальному использованию пропускной
способности сети, а так же усугубляют проблемы, связанные с БД и ORM - фреймворками,
такими, как `N + 1`.

Например в привычной архитектуре сервиса есть сущности, мапперы и DTO.
Сущности являются ядром сервиса, которые знают свою предметную область.
DTO -- это мост между сервисом и остальным миром,
а маппер -- это мост между сущностью и DTO, которые отображает поля сущности на поля DTO.

В большинстве сервисов так же есть некая центральная сущность (или несколько),
которые содержат в себе много полей и другие (дочерние) сущности. Например, в `JIRA`
такой сущностью является `issue`, то есть задача или проблема.

Проблема маппера в том, что он производит отображение безусловно,
в независимости от того, нужны ли клиенту сервиса эти данные или нет.

К примеру если клиентом сервиса выступает веб-модуль и он хочет отобразить в таблице
краткую сводку по центральной сущности приложения -- для этого ему нужно какое — то небольшое
кол — во ключевых полей. Но если клиент не может указать, какие поля ему нужны --
сервис будет каждый раз проделывать много бесполезной работы,
и сеть будет использоваться неоптимально.

== Как использовать

API и логика по выборочному отображению находятся в двух зависимостях:
[source,xml]
----
<dependencies>
    <dependency>
        <groupId>net.n2oapp.platform</groupId>
        <artifactId>n2o-platform-selection-api</artifactId>
    </dependency>
    <dependency>
        <groupId>net.n2oapp.platform</groupId>
        <artifactId>n2o-platform-selection-core</artifactId>
    </dependency>
</dependencies>
----

В API описаны два интерфейса `Selection<E>` и `Mapper<E>`.

В первом перечисляются поля, необходимые клиенту.
Делается это через метод, возвращающий `SelectionEnum` (в котором есть всего два значения,
`T` и `F` от `true` и `false` соответственно) без аргументов.
Данный метод так же должен быть помечен аннотацией `@SelectionKey("key")`.
Переменная типа `E` -- это тип данных, для которого предназначен этот `Selection`.

Например, для `issue` `REST API JIRA` реализация данного интерфейса может выглядеть так:

[source,java]
----
public class IssueSelection implements Selection<Issue> {

    private SelectionEnum selectKey; // Номер задачи
    private SelectionEnum selectAssignee; // Исполнитель
    private Selection<Assignee> assigneeSelection; // Вложенная выборка полей исполнителя
    private SelectionEnum selectStatus; // Статус
    private SelectionEnum selectProject; // Проект
//  ...

    @SelectionKey("key")
    public SelectionEnum getSelectKey() {
        return selectKey;
    }

    @SelectionKey("assignee")
    public SelectionEnum getSelectAssignee() {
        return selectAssignee;
    }

    @SelectionKey("assignee")
    public Selection<Assignee> getAssigneeSelection() {
        return assigneeSelection;
    }

    @SelectionKey("status")
    public SelectionEnum getSelectStatus() {
        return selectStatus;
    }

    @SelectionKey("project")
    public SelectionEnum getSelectProject() {
        return selectProject;
    }

//  ...

}
----

Аннотацию `@SelectionKey` можно так же указывать над соответствующим полем, но тогда надо убедиться,
что у этого поля есть стандартный геттер, который будет распознан методом
`org.springframework.beans.BeanUtils.getPropertyDescriptor`.

В приведенной выше выборке так же есть вложенная выборка `Selection<Assignee>`.
То есть поле `selectAssignee` говорит о том, что клиенту нужен исполнитель.
А поле `assigneeSelection` говорит о том, какие поля исполнителя нужны клиенту.
Заметьте, что у них должен быть совпадающий `@SelectionKey`.

Для данной выборки так же должная быть реализация интерфейса `Mapper`.
[source,java]
----
public class IssueMapper implements Mapper<Issue> {

    /**
    * Персистентная сущность
    */
    private final IssueEntity issue;

    public IssueMapper(IssueEntity issue) {
        this.issue = issue;
    }

    /**
    * @return Пустая модель DTO
    */
    @Override
    public Issue create() {
        return new Issue();
    }

    @SelectionKey("key")
    public void selectKey(Issue dto) {
        dto.setKey(issue.getKey());
    }

    @SelectionKey("assignee")
    public void selectAssignee(Issue dto, User assignee) {
        dto.setAssignee(assignee);
    }

    @SelectionKey("assignee")
    public Mapper<Assignee> assigneeMapper() {
        return new AssigneeMapper(issue.getAssignee());
    }

    @SelectionKey("status")
    public void selectStatus(Issue dto) {
        dto.setStatus(issue.getStatus());
    }

    @SelectionKey("project")
    public void setProject(Issue dto) {
        dto.setProject(issue.getProject());
    }

}
----

Здесь есть несколько ключевых моментов:

* Маппер возвращает пустую модель DTO (метод `create`). Это значит, что DTO не должна быть неизменяемой.

*   У маппера есть методы следующих видов:

**  Метод, который принимает модель DTO и кладет туда соответствующие данному `@SelectionKey` данные.
    Этим методам обычно соответствуют единичные поля сущности, например `key`.

**  А так же парные методы:
***     без аргументов, возвращающий вложенный `Mapper<X>`
***     и связанный с ним через `@SelectionKey` метод, принимающий DTO и `X`, который кладет в DTO `X`.

Как видно реализации `Selection` и `Mapper` достаточно похожи по структуре.

Имея данные реализации их можно использовать через метод `net.n2oapp.platform.selection.core.Selector.resolve(Mapper<E>, Selector<E>)`.

Данный метод в начале проверит, что переменную типа `E` интерфейса `Selection<E>` можно присвоить переменной типа `E` интерфейса `Mapper<E>`.

Так же он проверит все парные методы маппера на типобезопасность (с учетом дженериков).
Если где - то будет несоответствие -- будет брошено исключение.

Так же если в `Selection` указан `@SelectionKey`, о котором неизвестно мапперу -- будет брошено исключение.

Так же если у `Mapper`-а (или у `Selection`-а) будет вложенный `Mapper` (или `Selection`), но у соответствующего по
`@SelectionKey` `Selection`-а (или `Mapper`-а) не будет вложенного `Selection`-а (или `Mapper`-а) -- будет брошено исключение.

После этого будет произведена выборка полей. Для вложенных полей данный метод будет вызван рекурсивно.

== Генерация интерфейсов `Mapper` и `Selection` по `DTO`

Добавьте зависимость
[source,xml]
----
<dependency>
    <groupId>net.n2oapp.platform</groupId>
    <artifactId>n2o-platform-selection-processor</artifactId>
    <scope>compile</scope>
</dependency>
----

И укажите
[source,xml]
----
<build>
    <plugins>
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <executions>
                <execution>
                    <id>generate-sources</id>
                    <phase>generate-sources</phase>
                    <goals>
                        <goal>compile</goal>
                    </goals>
                    <configuration>
                        <annotationProcessors>
                            <annotationProcessor>net.n2oapp.platform.selection.processor.SelectionProcessor</annotationProcessor>
                        </annotationProcessors>
                        <compilerArgs>
                            <arg>-Anet.n2oapp.platform.selection.addJacksonTyping=?</arg>
                            <arg>-Anet.n2oapp.platform.selection.addJaxRsAnnotations=?</arg>
                            <arg>-Anet.n2oapp.platform.selection.overrideSelectionKeys</arg>
                        </compilerArgs>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

В `n2o-platform-selection-api` есть аннотация `@Selective`.
Она указывается над классом `DTO` и говорит о том, что выборка полей данного `DTO` происходит выборочно,
то есть через механизм, описанный выше.

Генератор кода распознает данную аннотацию и сгенерирует интерфейсы `Selection` и `Mapper` для каждого `DTO`.

Также он сгенерирует дефолтную реализацию для каждого интерфейса `Selection`.

У генератора кода есть три опции `net.n2oapp.platform.selection.addJacksonTyping`, `net.n2oapp.platform.selection.addJaxRsAnnotations` и `net.n2oapp.platform.selection.overrideSelectionKeys`.

Первая добавляет типизацию для Jackson-а. По-умолчанию `true`, если при компиляции присутствует аннотация `JsonTypeInfo`.

Вторая добавляет аннотации JAX-RS. Это позволяет передавать `Selection`-ы в параметрах запроса HTTP. По-умолчанию `true`, если при компиляции присутствует аннотация `QueryParam`.

Последняя (по-умолчанию `true`) указывает, что в дефолтных реализациях `Selection` при наличии наследования между ними в подклассах следует переопределять методы. Например, если есть:
[source,java]
----
public class BaseModel {
    private Integer id;
}
----

Для нее, помимо интерфейса, будет сгенерирован дефолтный `Selection`
[source,java]
----
public class DefaultBaseModelSelection<A extends BaseModel> implements BaseModelSelection<A> {

	@QueryParam("baseModelPropagation")
	protected SelectionPropagationEnum propagation;

	public SelectionPropagationEnum getPropagation() {
		return propagation;
	}

	public void setPropagation(SelectionPropagationEnum propagation) {
		this.propagation = propagation;
	}

	@Override
	public SelectionPropagationEnum propagation() {
		return propagation;
	}

	public DefaultBaseModelSelection<A> propagate(SelectionPropagationEnum propagation) {
		this.propagation = propagation;
		return this;
	}

	@QueryParam("baseModelId")
	private SelectionEnum id;

	@Override
	public SelectionEnum getId() {
		return id;
	}

	public void setId(SelectionEnum id) {
		this.id = id;
	}

	/**
    * Будет переопределен
    */
	public DefaultBaseModelSelection<A> id() {
		this.id = SelectionEnum.T;
		return this;
	}

	/**
    * Будет переопределен
    */
	public DefaultBaseModelSelection<A> unselectId() {
		this.id = SelectionEnum.F;
		return this;
	}

}
----

Если у BaseModel есть наследник `SomeModel`, и указана опция `overrideSelectionKeys`, то для `SomeModel` дефолтная реализация будет такой:
[source,java]
----
public class DefaultSomeModelSelection extends DefaultBaseModelSelection<SomeModel> implements SomeModelSelection {

	public DefaultSomeModelSelection propagate(SelectionPropagationEnum propagation) {
		this.propagation = propagation;
		return this;
	}

	/**
    * Переопределено из DefaultBaseModelSelection
    */
	@Override
	public DefaultSomeModelSelection id() {
		return (DefaultSomeModelSelection) super.id();
	}


	/**
    * Переопределено из DefaultBaseModelSelection
    */
	@Override
	public DefaultSomeModelSelection unselectId() {
		return (DefaultSomeModelSelection) super.unselectId();
	}

}
----

Это позволяет использовать `call-chain` (по аналогии с методами `append` класса `StringBuilder`) без явных кастов. Например:
[source,java]
----
DefaultSomeModelSelection selection = SomeModelSelection.create().id(); // тут потребуется явный каст, если бы переопределения не было
----

Главное преимущество в использовании генератора кода -- типобезопасность.

== Ограничения

Чтобы соответствовать HTTP соглашениям по поводу получения данных и в то же время эффективно использовать данный API --
нужно проектировать свою модель правильно.

По соглашениям получение данных должно осуществляться через GET запрос.
Тело может присутствовать в запросе, но оно не должно влиять на результат, он полностью определяется
URI и параметрами (QueryParam) запроса. Так как параметры запроса имеют плоскую модель
(по сути это отображение `ключ` -> `список значений`) -- очень сложно описать в них иерархическую модель (подобную JSON).

Например, допустим у нас есть класс `Organisation`, в котором есть два поля типа `Address`, юридический и фактический адреса.
[source,java]
----
@Selective
public class Organisation {

    Address legal; // Юридический адрес
    Address factual; // Фактический адрес

    @Selective
    public static class Address {
        String postcode; // Почтовый код
        String region; // Регион
//      ...
    }

}
----
Выборки из обоих полей описываются одним и тем же `AddressSelection`:
[source,java]
----
public class OrganisationSelection {

    @QueryParam("selectLegal")
    SelectionEnum selectLegal;

    @QueryParam("selectLegal")
    SelectionEnum selectFactual;

    @BeanParam
    AddressSelection legalSelection; // Вложенная выборка

    @BeanParam
    AddressSelection factualSelection; // Вложенная выборка

    public static class AddressSelection {

        @QueryParam("selectPostcode")
        SelectionEnum selectPostcode;

        @QueryParam("selectRegion")
        SelectionEnum selectRegion;

//      ...
    }

}
----

Невозможно через параметры запроса указать (по крайней мере в JAX-RS, через `@BeanParam`),
что из юридического адреса нам нужен почтовый код, а из фактического регион, так как
в строке запроса это выглядит так:
`http://rest-api/organisations?selectLegal=T&selectFactual=T&selectPostcode=T&selectRegion=T`

В итоге сервис отдаст оба адреса, с заполненными почтовым кодом и регионом.

Это лишь один пример того, что нужно иметь в виду при проектировании модели данных.
В общем случае нужно делать так, чтобы ваши `DTO` были максимально плоскими.
Так же не используйте наследование, используйте композицию.

Но можно избежать этих трудностей, если передавать выборку в параметре запроса в формате JSON.

Если же описания выборок становятся очень большими, единственный выход -- нарушить соглашения по построению REST-сервисов и отдавать
данные по POST запросу с Body. Так вы можете описать произвольно сложную и большую выборку в формате JSON.
Примеры известных систем, использующих подобный подход:

* GraphQL
* ElasticSearch
* JIRA REST API

Но нужно понимать, что оверхед на передачу выборки не должен превышать профит от ее использования. Иначе вам не стоит
использовать данный API.

В целом у вас есть 3 опции:

* Описывать выборку параметрами запроса, например так:
[source,java]
----
public class SomeCriteria extends RestCriteria {

    @BeanParam
    private SomeSelection selection;

//  Фильтры опущены

    public class SomeSelection implements Selection<SomeModel> {

        @QueryParam("selectField1")
        private SelectionEnum selectField1;

        @QueryParam("selectField2")
        private SelectionEnum selectField2;
//      ...
    }

}
----

Это самый правильный и чистый подход

* Описывать выборку в JSON и передавать ее в параметре запроса:
[source,java]
----
public class SomeCriteria extends RestCriteria {

    @QueryParam("selection")
    private String selection; // Здесь лежит JSON

    public String getSelection() {
        return selection;
    }

    public void setSelection(String selection) {
        this.selection = selection;
    }

    public void setSelection(SomeSelection selection) {
        this.selection = Selection.toString(selection);
    }

    public SomeSelection selection() {
        return Selection.parse(selection, SomeSelection.class);
    }

}
----
Вам следует использовать статические методы `net.n2oapp.platform.selection.api.Selection.toString` и `net.n2oapp.platform.selection.api.Selection.parse` для этого (они `null-safe`).
Они кодируют JSON таким образом, что это позволяет избежать кодирования процентами в строке запроса URI и сохраняет место (помните, что безопасным лимитом длины URI является 2048 символов).

* Передавать выборку в теле запроса:
[source,java]
----
@Path("/example")
public class SomeService {
    @POST
    @Path("/search")
    Page<SomeModel> search(@BeanParam SomeCriteria criteria, SomeSelection selection); // Второй параметр -- это тело запроса
}
----

В начале стоит использовать первый подход.

Если его начинает не хватать по гибкости -- перейти на второй.

И только если выборка становится настолько большой, что не умещается в параметре запроса
(и профит от ее использования не превышает оверхед на ее передачу) --
нужно использовать третий.

Иначе не стоит использовать данный API.

== Почему не GraphQL

GraphQL -- это мощный фреймворк, созданный для тех же целей. Почему бы не использовать его?

На самом деле причин не использовать его немного. Просто данный API дает возможность сохранить привычную модель REST-сервисов, в котором есть множество эндпоинтов, каждый из которых имеет свою ограниченную зону ответственности. В GraphQL же на все приходится один POST-эндпоинт, отвечающий за все.

Также данный API более удобен для Java-разработчика, потому что достаточно лишь описать свои POJO модели. В GraphQL же нужно в начале описать схему (помимо той, что уже есть в БД) и после этого воспользоваться генератором кода для создания POJO моделей и интерфейсов.

В существующие сервисы можно легко встроить данный API, в то время как с GraphQL потребуется достаточно глобальный рефакторинг.

Ну и в последних выразительная сила GraphQL выходит далеко за рамки того, чтобы просто указать, что "мне нужны такие — то поля". По сути это целый язык запросов. И использование его лишь для описания полей в выборке кому — то может показать большим оверхедом.